// 先来看看先行断言
// 先行断言就是你遇到一个条件，然后判断后面这个是否满足
// let test = 'hello world'
// ["hello", index: 0, input: "hello world", groups: undefined]
// console.log(test.match(/hello(?=\sworld)/))

// 后行断言
// 后行断言就是你遇到一个条件，然后判断前面这个是否满足
// console.log(test.match(/(?<=hello\s)world/))
// ["world", index: 6, input: "hello world", groups: undefined]
// 也可以用不等于
// console.log(test.match(/(?<!heleo\s)world/))
// (?<…)是后行断言的符号，(?..)是先行断言的符号，然后结合 =(等于)、!(不等)、\1(捕获匹配)。

// 后行断言练习
// 练习一：请把 ‘$foo %foo foo’ 字符串中前面是 $ 符号的 foo 替换成 bar。
// let str = '$foo %foo foo'
// let t = /(?<=\$)foo/g
// console.log(str.replace(t, 'bar'))

// 练习二 请提取 ‘2 $1 is worth about ¥123’ 字符中的美元数是多少。
let str = '2 $12578 $12 is worth about ¥123'
// let t = str.match(/(?<=\$)\d/)
// \d只能匹配一个数字，而\d+可以匹配多个数字
let t = /(?<=\$)\d+/g
console.log(str.match(t))

// \d$以最后一个数字
console.log(/(?<=(\d+)(\d+))\d$/.exec('10583')) // ["3", "1", "058"]
console.log(/(?<=(\d+)(\d+))53/.exec('1053')) // 53 1 0

// //后行断言只关心后边的匹配，如果后边没有匹配项,前面的类似于懒惰，给了一个匹配项那就是贪婪，并且是从右向左的贪婪
// 例一、后行断言的右侧没有匹配项，只有一个后行断言，此时后行断言就类似于懒惰匹配，仅仅匹配到2个数字‘1’ ‘0’
// /(?<=(\d+)(\d+))/.exec('1053'); //["", "1", "0"]
// 例二、后行断言的右侧只给了一个 $ ,那么后行断行就会贪婪匹配，内部也是从右向左，多以第二个括号会匹配到053，而第一个仅仅是 1
// /(?<=(\d+)(\d+))$/.exec('1053'); // ["", "1", "053"];
// 例三、由此可以看到，除了整个正则表达式匹配到了一个3以外，对于后行断言没有任何影响，结果与例二一样
// /\d(?<=(\d+)(\d+))$/.exec('1053'); //["3", "1", "053"]
// 例四、下面是对正常后行断言的展示
// /(?<=(\d+)(\d+))\d$/.exec('1053'); //["3", "1", "05"]
// /(?<=(\d+)(\d+))53/.exec('1053'); //["53", "1", "0"]
// ————————————————
// 版权声明：本文为CSDN博主「xingyemeng1202」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
// 原文链接：https://blog.csdn.net/u013182438/article/details/81181807
